عندي مشروع Flask / Python يستعمل Gemini بعدّة مفاتيح API (GEMINI_KEY_1..GEMINI_KEY_n) مع نظام تدوير للمفاتيح، لكن حاليًا كل الطلبات تقريبًا ترجع RESOURCE_EXHAUSTED لأن المشروع يستخدم النموذج gemini-2.5-pro.

أريدك أن تقوم بالآتي، خطوة بخطوة، بدون كسر أي أداة أو endpoint للمستخدمين:

1) نقل المشروع بالكامل من gemini-2.5-pro إلى موديل أخف

ابحث في المشروع عن كل الأماكن التي يتم فيها إنشاء موديل Gemini، مثلًا أي سطر يحتوي على:

GenerativeModel('gemini-2.5-pro')

أو أي اسم موديل Pro مشابه.

استبدل الموديل الافتراضي في كل هذه المواضع بنموذج أخف يدعم الـ free tier بشكل أفضل، وليكن:

gemini-2.0-flash كنموذج افتراضي للنص والصوت والصور (لو مناسب)،
أو gemini-2.5-flash لو كان هو النموذج المستخدم في المشروع أصلًا.

بدلًا من كتابة اسم الموديل بشكل ثابت، أنشئ متغيرات إعداد في الكود تقرأ من الـ Environment، مثلًا:

GEMINI_TEXT_MODEL (للنص والصوت)

GEMINI_VISION_MODEL (للرؤية/الصور)
واجعل قيمتها الافتراضية في الكود:

gemini-2.0-flash

استخدم هذه المتغيرات في دوال المساعدة الحالية (call_gemini_text, call_gemini_vision, وأي دوال أخرى تعتمد على GenerativeModel)، بحيث يمكنني لاحقًا تغيير الموديل من الـ Environment بدون تعديل الكود.

تأكد من أن جميع الأدوات التي تعتمد على Gemini (تحويل الصوت لنص، التعرف على البودكاست، تحليل النصوص… إلخ) تستخدم الموديل الخفيف الجديد وليس أي موديل Pro.

2) تقليل استهلاك الكوتا بدون تغيير تجربة المستخدم

راجع دوال المساعدة call_gemini_text و call_gemini_vision وأي مكان يتم فيه استدعاء Gemini:

تأكد أنه لا يوجد غيارات (retries) مبالغ فيها. يكفي:

إعادة المحاولة على مفاتيح مختلفة بحد أقصى 2 مفاتيح لكل طلب.

لا تقم بعمل loop طويل يجرب كل المفاتيح عشرات المرات.

لو كان هناك prompts طويلة جدًا يتم إرسالها دائمًا، اجعل الدوال:

تقطع النص إلى حد منطقي عند الحاجة، أو

تستخدم صيغة Prompt مختصرة، لكن احرص على ألا تغيّر سلوك الأداة للمستخدم (نفس النتيجة المتوقعة قدر الإمكان).

تأكد أن الأدوات التي لا تحتاج فعليًا إلى ذكاء اصطناعي لا تستدعي Gemini نهائيًا، خصوصًا:

قص فيديو يوتيوب

تحميل الفيديو/الصوت من أي موقع

فصل الموسيقى عن الصوت

أي أدوات تعتمد أساسًا على yt-dlp أو ffmpeg أو مكتبات معالجة ملفات بدون AI
لو وجدت أي استدعاء غير ضروري لـ call_gemini_* داخل هذه الأدوات، قم بإزالته أو جعله اختياريًا فقط عند ضغط المستخدم على زر خاص.

3) تحسين التعامل مع استنفاد الكوتا لكل المفاتيح

حافظ على نظام التدوير الحالي للمفاتيح (GEMINI_KEY_1..GEMINI_KEY_50)، لكن حدّثه ليتوافق مع الموديل الخفيف الجديد.

عندما يرجع أحد المفاتيح خطأ من نوع:

429, RESOURCE_EXHAUSTED, أو أي رسالة كوتا مشابهة
قم بما يلي:

علّم هذا المفتاح كـ "exhausted" وضع له وقت cooldown منطقي (مثلاً 60 دقيقة) في الذاكرة أو في البنية الحالية التي تدير المفاتيح.

انتقل إلى مفتاح آخر متاح، لكن لا تلف على جميع المفاتيح عشرات المرات.

عندما تنفد جميع المفاتيح بالفعل:

لا تحاول عمل حلقات محاولات بلا نهاية.

أرجع للمستخدم رسالة عربية واضحة (كما هو موجود حاليًا) مع الاحتفاظ بنفس النص أو تحسينه، مثل:

"تم استنفاد حصة جميع مفاتيح الذكاء الاصطناعي المتاحة حاليًا. جرّب لاحقًا أو أضف مفاتيح جديدة."

وفي اللوج اطبع رسالة مختصرة توضّح أن المشكلة من الكوتا وليس من الكود.

4) التحقق وعدم كسر أي أداة

بعد الانتهاء من التعديلات، اختبر الأدوات الآتية للتأكد أن كل شيء يعمل:

تحويل ملف صوتي إلى نص (باستخدام الملف التجريبي الموجود في المشروع أو أي ملف قصير).

تحويل الصوت المباشر إلى نص (لو موجود).

أداة التعرف على البودكاست / الأنمي / الصورة (إن كانت تعتمد على Gemini Vision).

أدوات القص والتحميل من يوتيوب ومن أي موقع، للتأكد أنها لا تتأثر بنقل النموذج.

تأكد أن:

كل الـ routes واسماء الـ endpoints لم تتغير.

شكل بيانات الـ JSON المرسل والمستقبل لم يتغير.

الرسائل المعروضة للمستخدم باللغة العربية تظل مفهومة كما هي أو أفضل.

لا تعرض لي الكود في الرد، عدّل الملفات مباشرة داخل المشروع، وأعد تشغيل التطبيق/السيرفر وتأكد أنه يعمل بدون أخطاء.

الهدف النهائي:
أن ينتقل المشروع بالكامل من الاعتماد على gemini-2.5-pro إلى نموذج Flash أخف (مثل gemini-2.0-flash)، مع الحفاظ على جميع الأدوات كما هي، وتقليل استهلاك الكوتا قدر الإمكان، بحيث تقل بشكل واضح رسائل "تم استنفاذ جميع المفاتيح" التي تظهر للمستخدم.